import os
import ffmpeg
import argparse
from pathlib import Path

# Standalone video compressor, part of the Rawrify project.
# Launching this as a separate component of Rawrify since video compression is tricky due to file size and service
# limits in AWS for things like API Gateway (e.g. no payload sizes greater than 10 MB).


# Convert input files from .mov to .mp4 if needed. I've run into this when transferring files from my iPhone
def convert_mov(video_path, output_name):
    print(f"Converting {video_path} from .mov to .mp4 -> output at {output_name}")
    input_video = ffmpeg.input(video_path)
    ffmpeg.output(input_video, output_name,
                  **{"vcodec": "h264", "acodec": "aac"},
                  ).overwrite_output().run()


# Compress a video file at a given input path to a defined size, then output it to the specified path/name
def compress_video(video_path, output_name, size):
    print(f"Compressing {video_path}...")
    # Set lower and upper bounds for audio bitrate
    min_bitrate = 32000
    max_bitrate = 256000

    # Prepping variables and objects that will help in the compression process
    probe = ffmpeg.probe(video_path)
    length = float(probe["format"]["duration"])
    audio_bitrate = float(next((s for s in probe['streams'] if s['codec_type'] == 'audio'), None)['bit_rate'])
    target_total_bitrate = (size * 1024 * 8) / (1.073741824 * length)

    # ffmpeg does not like bitrates lower than 11000
    if target_total_bitrate < 11000:
        raise ValueError("Target size too low. Total bitrate must be greater than 11000 or else ffmpeg will throw errors.")

    # Target audio bitrate, in bps
    if 10 * audio_bitrate > target_total_bitrate:
        audio_bitrate = target_total_bitrate / 10
        if audio_bitrate < min_bitrate < target_total_bitrate:
            audio_bitrate = min_bitrate
        elif audio_bitrate > max_bitrate:
            audio_bitrate = max_bitrate
    # Target video bitrate, in bps.
    video_bitrate = target_total_bitrate - audio_bitrate

    # Run the compression process using a two-run approach (not required but tends to work better)
    # These commands are all equivalent to command line operations (the python-ffmpeg library is really just a wrapper)
    try:
        input_video = ffmpeg.input(video_path)
        ffmpeg.output(input_video, os.devnull,
                      **{'c:v': 'libx264', 'b:v': video_bitrate, 'pass': 1, 'f': 'mp4'}
                      ).overwrite_output().run()
        ffmpeg.output(input_video, output_name,
                      **{'c:v': 'libx264', 'b:v': video_bitrate, 'pass': 2, 'c:a': 'aac', 'b:a': audio_bitrate}
                      ).overwrite_output().run()
        print(f"Done compressing {video_path}, check {output_name} for output file.")
    except Exception as e:
        # Error cleanup-- remove the empty output file generated by ffmpeg
        os.remove(output_name)
        raise
    finally:
        # Cleanup
        os.remove("ffmpeg2pass-0.log")
        os.remove("ffmpeg2pass-0.log.mbtree")


# An orchestrator function to handle processing a video, including conversion from .mov format and compressing
def process_video(video_path, size, process_mov):
    print(f">>> Processing {input_file}...")
    converted_video_filename = video_path

    # Convert input files from .mov to .mp4 format by default
    if input_file[-4:] == ".mov" and process_mov:
        converted_video_filename = video_path.replace('.mov', '.mp4')
        convert_mov(video_path, converted_video_filename)
    processed_video_filename = f"{converted_video_filename[:-4]}-compressed{converted_video_filename[-4:]}"
    compress_video(converted_video_filename, processed_video_filename, size)


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Compress a video to a desired size. Also convert .mov to .mp4 if needed")
    parser.add_argument("--desired_size", type=float, help="The desired size for the video file in kilobits.",
                        required=True)
    parser.add_argument("--video_path", type=str, help="The path to the video file. If not supplied, defaults to the input/ folder in this project's local directory.",
                        required=False)
    parser.add_argument("--no-convert-mov", dest="convert_mov_file", action="store_false")
    parser.set_defaults(convert_mov_file=True)
    user_args = parser.parse_args()

    # user input validation
    if user_args.video_path and not os.path.exists(user_args.video_path):
        raise ValueError(f"Supplied video path does not exist. Tried {user_args.video_path}")
    if user_args.video_path:
        validation_path = Path(user_args.video_path)
        if not validation_path.is_file():
            raise ValueError(f"Only individual files are supported for the --video_path parameter. If you want to process a "
                            f"set of videos, please put them in the project directory's 'input/' folder and omit the --video_path argument.")
    if not user_args.video_path:
        input_dir = os.listdir("input")
        if len(input_dir) == 0:
            raise ValueError("The input/ directory is empty and --video_path is null. Please either supply a --video_path"
                             " argument or place video files into the project's local input/ directory.")

    # Process the user-supplied videos!
    try:
        if user_args.video_path:
            process_video(user_args.video_path, user_args.desired_size * 1000, user_args.convert_mov_file)
        else:
            for input_file in os.listdir("input"):
                # Only process files that aren't the README in the input/ folder
                if input_file != "README.md":
                    process_video(f"input/{input_file}", user_args.desired_size * 1000, user_args.convert_mov_file)
    except FileNotFoundError as e:
        print("ffmpeg not installed, please install ffmpeg")

